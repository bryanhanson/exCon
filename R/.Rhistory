callGraph <- function(lang = "d3", excludeFile = NULL, ext = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, exFnPat = NULL,#
	addFnPat = NULL, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				fnNames <- c(fnNames, filesL[[i]][j])#
				fnFileNames <- c(fnFileNames, names(filesL)[i])#
				fnFileNo <- c(fnFileNo, i)#
				fnSt <- c(fnSt, j)#
				Verbose <- ifelse(verbose == 2L, TRUE, FALSE)#
				end <- findClosingBrace(fL = filesL, i = i, j = j,#
					jmax = length(filesL[[i]]), Verbose = Verbose)#
 				fnEnd <- c(fnEnd, end)#
			}		#
     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
    df <- data.frame(fnName = fnNames, file = fnFileNames[-1],#
    		fileIdx = fnFileNo[-1], stLine = fnSt[-1], endLine = fnEnd[-1],#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("WARNING: duplicate function names were found")#
    df <- df[!dup,]#
    if (verbose >= 1L) {#
    		message("Done processing files, ready to map the function calls")#
    		message("Set 'verbose = 2' to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose == 2L, TRUE, FALSE)#
 	cM <- findFnCallInFile(fL = filesL, df = df, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
    if (verbose >= 1L) message("Done mapping the function calls")#
    return(cM)#
	}
findClosingBrace <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found closing brace for:", fL[[i]][ji], "\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found closing brace for:", fL[[i]][ji], "\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFile <- function(fL = NULL, df = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	keep <- unique(df$fileIdx)#
	enbedLvl <- c(NA_integer_)#
  	for (i in keep) { #
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		enbedLvl <- c(enbedLvl, tmp)#
		}#
	enbedLvl <- enbedLvl[-1]#
	df$enbedLvl <- enbedLvl#
    write.csv(file = "~/Desktop/fn.csv", df)#
	callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
	dimnames(callMat) <- list(df[,1], df[,1])#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
			}		#
		} #
	return(callMat) #
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnPat)) sp <- c(sp, paste(addFnPat, df[,1], sep = ""))#
	if (Verbose) message("\n\nLooking inside: ", df[i,1], "\n")#
	nextLine <- FALSE #
	for (k in 1:length(sp)) {#
		if (Verbose) cat("\tSearching for: ", df[k,1], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnPat)) {#
					for (n in 1:length(exFnPat)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnPat[n], fL[[fNo]][j]))) {#
							cMat[i,(k %% spl)] <- 1L#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnPat[n], fL[[fNo]][j]))) {#
							print("Excluding this one:")#
							cat("Line to check is:", fL[[fNo]][j], "\n")#
							}#
						}#
					}#
				if (is.null(exFnPat)) cMat[i,(k %% spl)] <- 1L#
#
				if (Verbose) {#
					msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
						"\n\t\t\t\tin file", names(fL)[fNo],#
						"at line", j, "\n", sep = " ")#
					cat(msg)#
					}#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df, Verbose = FALSE) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
callGraph <- function(lang = "d3", excludeFile = NULL, ext = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, exFnPat = NULL,#
	addFnPat = NULL, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				fnNames <- c(fnNames, filesL[[i]][j])#
				fnFileNames <- c(fnFileNames, names(filesL)[i])#
				fnFileNo <- c(fnFileNo, i)#
				fnSt <- c(fnSt, j)#
				Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
				end <- findClosingBrace(fL = filesL, i = i, j = j,#
					jmax = length(filesL[[i]]), Verbose = Verbose)#
 				fnEnd <- c(fnEnd, end)#
			}		#
     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
    df <- data.frame(fnName = fnNames, file = fnFileNames[-1],#
    		fileIdx = fnFileNo[-1], stLine = fnSt[-1], endLine = fnEnd[-1],#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("WARNING: duplicate function names were found")#
    df <- df[!dup,]#
    if (verbose >= 1L) {#
    		message("Done processing files, ready to map the function calls")#
    		message("Set verbose = 2 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose == 2L, TRUE, FALSE)#
 	cM <- findFnCallInFile(fL = filesL, df = df, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
    if (verbose >= 1L) message("Done mapping the function calls")#
    return(cM)#
	}
tst <- callGraph(lang = "R", verbose = 0)
tst <- callGraph(lang = "R", verbose = 1)
callGraph <- function(lang = "d3", excludeFile = NULL, ext = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, exFnPat = NULL,#
	addFnPat = NULL, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				fnNames <- c(fnNames, filesL[[i]][j])#
				fnFileNames <- c(fnFileNames, names(filesL)[i])#
				fnFileNo <- c(fnFileNo, i)#
				fnSt <- c(fnSt, j)#
				Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
				end <- findClosingBrace(fL = filesL, i = i, j = j,#
					jmax = length(filesL[[i]]), Verbose = Verbose)#
 				fnEnd <- c(fnEnd, end)#
			}		#
     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
    df <- data.frame(fnName = fnNames, file = fnFileNames[-1],#
    		fileIdx = fnFileNo[-1], stLine = fnSt[-1], endLine = fnEnd[-1],#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("WARNING: duplicate function names were found")#
    df <- df[!dup,]#
    if (verbose >= 1L) {#
    		message("Done processing files, ready to map the function calls")#
    		message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
 	cM <- findFnCallInFile(fL = filesL, df = df, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
    if (verbose >= 1L) message("Done mapping the function calls")#
    return(cM)#
	}
callGraph <- function(lang = "d3", excludeFile = NULL, ext = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, exFnPat = NULL,#
	addFnPat = NULL, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				fnNames <- c(fnNames, filesL[[i]][j])#
				fnFileNames <- c(fnFileNames, names(filesL)[i])#
				fnFileNo <- c(fnFileNo, i)#
				fnSt <- c(fnSt, j)#
				Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
				end <- findClosingBrace(fL = filesL, i = i, j = j,#
					jmax = length(filesL[[i]]), Verbose = Verbose)#
 				fnEnd <- c(fnEnd, end)#
			}		#
     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
    df <- data.frame(fnName = fnNames, file = fnFileNames[-1],#
    		fileIdx = fnFileNo[-1], stLine = fnSt[-1], endLine = fnEnd[-1],#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("WARNING: duplicate function names were found")#
    df <- df[!dup,]#
    if (verbose >= 1L) {#
    		message("Done processing files, ready to map the function calls")#
    		if (verbose == 1) message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
 	cM <- findFnCallInFile(fL = filesL, df = df, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
    if (verbose >= 1L) message("Done mapping the function calls")#
    return(cM)#
	}
findClosingBrace <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found closing brace for:", fL[[i]][ji], "\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFile <- function(fL = NULL, df = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	keep <- unique(df$fileIdx)#
	enbedLvl <- c(NA_integer_)#
  	for (i in keep) { #
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		enbedLvl <- c(enbedLvl, tmp)#
		}#
	enbedLvl <- enbedLvl[-1]#
	df$enbedLvl <- enbedLvl#
    write.csv(file = "~/Desktop/fn.csv", df)#
	callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
	dimnames(callMat) <- list(df[,1], df[,1])#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
			}		#
		} #
	return(callMat) #
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnPat)) sp <- c(sp, paste(addFnPat, df[,1], sep = ""))#
	if (Verbose) message("\n\nLooking inside: ", df[i,1], "\n")#
	nextLine <- FALSE #
	for (k in 1:length(sp)) {#
		if (Verbose) cat("\tSearching for: ", df[k,1], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnPat)) {#
					for (n in 1:length(exFnPat)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnPat[n], fL[[fNo]][j]))) {#
							cMat[i,(k %% spl)] <- 1L#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnPat[n], fL[[fNo]][j]))) {#
							print("Excluding this one:")#
							cat("Line to check is:", fL[[fNo]][j], "\n")#
							}#
						}#
					}#
				if (is.null(exFnPat)) cMat[i,(k %% spl)] <- 1L#
#
				if (Verbose) {#
					msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
						"\n\t\t\t\tin file", names(fL)[fNo],#
						"at line", j, "\n", sep = " ")#
					cat(msg)#
					}#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df, Verbose = FALSE) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
findClosingBrace <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found closing brace for:", fL[[i]][ji], "\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFile <- function(fL = NULL, df = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	keep <- unique(df$fileIdx)#
	enbedLvl <- c(NA_integer_)#
  	for (i in keep) { #
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		enbedLvl <- c(enbedLvl, tmp)#
		}#
	enbedLvl <- enbedLvl[-1]#
	df$enbedLvl <- enbedLvl#
    write.csv(file = "~/Desktop/fn.csv", df)#
	callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
	dimnames(callMat) <- list(df[,1], df[,1])#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
			}		#
		} #
	return(callMat) #
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnPat)) sp <- c(sp, paste(addFnPat, df[,1], sep = ""))#
	if (Verbose) message("\n\nLooking inside: ", df[i,1], "\n")#
	nextLine <- FALSE #
	for (k in 1:length(sp)) {#
		if (Verbose) cat("\tSearching for: ", df[k,1], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnPat)) {#
					for (n in 1:length(exFnPat)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnPat[n], fL[[fNo]][j]))) {#
							cMat[i,(k %% spl)] <- 1L#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnPat[n], fL[[fNo]][j]))) {#
							print("Excluding this one:")#
							cat("Line to check is:", fL[[fNo]][j], "\n")#
							}#
						}#
					}#
				if (is.null(exFnPat)) cMat[i,(k %% spl)] <- 1L#
#
				if (Verbose) {#
					msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
						"\n\t\t\t\tin file", names(fL)[fNo],#
						"at line", j, "\n", sep = " ")#
					cat(msg)#
					}#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
tst <- callGraph(lang = "R", verbose = 3)
findClosingBrace <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found closing brace for:", fL[[i]][ji], "\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFile <- function(fL = NULL, df = NULL, exFnPat = NULL,#
	addFnPat = NULL, Verbose = FALSE) {#
	keep <- unique(df$fileIdx)#
	enbedLvl <- c(NA_integer_)#
  	for (i in keep) { #
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		enbedLvl <- c(enbedLvl, tmp)#
		}#
	enbedLvl <- enbedLvl[-1]#
	df$enbedLvl <- enbedLvl#
    write.csv(file = "~/Desktop/fn.csv", df)#
	callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
	dimnames(callMat) <- list(df[,1], df[,1])#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
			}		#
		} #
	return(callMat) #
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnPat)) sp <- c(sp, paste(addFnPat, df[,1], sep = ""))#
	if (Verbose) message("\n\nLooking inside: ", df[i,1], "\n")#
	nextLine <- FALSE #
	for (k in 1:length(sp)) {#
		if (Verbose) cat("\tSearching for: ", df[k,1], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnPat)) {#
					for (n in 1:length(exFnPat)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnPat[n], fL[[fNo]][j]))) {#
							cMat[i,(k %% spl)] <- 1L#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnPat[n], fL[[fNo]][j]))) {#
							print("Excluding this one:")#
							cat("Line to check is:", fL[[fNo]][j], "\n")#
							}#
						}#
					}#
				if (is.null(exFnPat)) cMat[i,(k %% spl)] <- 1L#
#
				if (Verbose) {#
					msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
						"\n\t\t\t\tin file", names(fL)[fNo],#
						"at line", j, "\n", sep = " ")#
					cat(msg)#
					}#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
tst <- callGraph(lang = "R", addFnPat = "do\\.call\\(")
callGraph <- function(lang = "d3", excludeFile = NULL, ext = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, exFnPat = NULL,#
	addFnPat = NULL, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				fnNames <- c(fnNames, filesL[[i]][j])#
				fnFileNames <- c(fnFileNames, names(filesL)[i])#
				fnFileNo <- c(fnFileNo, i)#
				fnSt <- c(fnSt, j)#
				Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
				end <- findFnDefinition(fL = filesL, i = i, j = j,#
					jmax = length(filesL[[i]]), Verbose = Verbose)#
 				fnEnd <- c(fnEnd, end)#
			}		#
     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
    df <- data.frame(fnName = fnNames, file = fnFileNames[-1],#
    		fileIdx = fnFileNo[-1], stLine = fnSt[-1], endLine = fnEnd[-1],#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("WARNING: duplicate function names were found")#
    df <- df[!dup,]#
    if (verbose >= 1L) {#
    		message("Done processing files, ready to map the function calls")#
    		if (verbose == 1) message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
 	cM <- findFnCallInFile(fL = filesL, df = df, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
    if (verbose >= 1L) message("Done mapping the function calls")#
    return(cM)#
	}
tmp <- gplot(tst, displaylabels = TRUE, label.cex = 0.6,#
	arrowhead.cex = 0.5, label.pos = 6, diag = TRUE, mode = "circle", ylim = c(-1.15, 1.15), xlim = c(-1.15, 1.15))
tst
findFnDefinition <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFile <- function(fL = NULL, df = NULL, exFnPat = NULL,#
	addFnPat = NULL, Verbose = FALSE) {#
	keep <- unique(df$fileIdx)#
	enbedLvl <- c(NA_integer_)#
	if (Verbose >= 2) message("Checking embed depth")#
  	for (i in keep) { #
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		enbedLvl <- c(enbedLvl, tmp)#
		}#
	enbedLvl <- enbedLvl[-1]#
	df$enbedLvl <- enbedLvl#
    write.csv(file = "~/Desktop/fn.csv", df)#
	callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
	dimnames(callMat) <- list(df[,1], df[,1])#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnPat = exFnPat, addFnPat = addFnPat, Verbose = Verbose)#
			}		#
		} #
	return(callMat) #
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnPat = NULL, addFnPat = NULL, Verbose = FALSE) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnPat)) sp <- c(sp, paste(addFnPat, df[,1], sep = ""))#
	if (Verbose) message("\n\nLooking inside: ", df[i,1], "\n")#
	nextLine <- FALSE #
	for (k in 1:length(sp)) {#
		if (Verbose) cat("\tSearching for: ", df[k,1], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnPat)) {#
					for (n in 1:length(exFnPat)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnPat[n], fL[[fNo]][j]))) {#
							cMat[i,(k %% spl)] <- 1L#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnPat[n], fL[[fNo]][j]))) {#
							print("Excluding this one:")#
							cat("Line to check is:", fL[[fNo]][j], "\n")#
							}#
						}#
					}#
				if (is.null(exFnPat)) cMat[i,(k %% spl)] <- 1L#
#
				if (Verbose) {#
					msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
						"\n\t\t\t\tin file", names(fL)[fNo],#
						"at line", j, "\n", sep = " ")#
					cat(msg)#
					}#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
tst <- callGraph(lang = "R", verbose = 2)
library('sna')
library("gsubfn")
library()
library("stringr")
findFnDefinition <- function(fL = NULL, i = NULL, j = NULL,#
	jmax = NULL, Verbose = FALSE) {#
	ji <- j#
	if (Verbose) cat("\tSearching for closing brace of:", fL[[i]][ji], "\n")#
	cnt <- 0L #
	foundOne <- FALSE#
	while (j <= jmax) {#
		if (grepl(pattern = "\\{", x = fL[[i]][j])) {#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\{"), na.rm = TRUE)#
			cnt <- cnt + no#
			foundOne <- TRUE#
			}#
		if (grepl(pattern = "\\}", x = fL[[i]][j])) {#
			if ((cnt == 1)) {#
				if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
				return(j)#
				}	#
			no <- sum(str_count(unlist(strsplit(fL[[i]][j], "")), "\\}"), na.rm = TRUE)#
			cnt <- cnt - no#
			}#
		if ((cnt == 0) & (!foundOne)) {#
			j <- j + 1#
			next#
			}#
		if (cnt == 0) {#
			if (Verbose) cat("\t\tYippee! Found the closing brace!\n\n")#
			return(j)#
			}#
		j <- j + 1#
		}#
	} #
findFnCallInFn <- function(fL = NULL, df = NULL, exFnNode = NULL,#
	addFnCall = NULL, exFnCall = NULL, main = TRUE, Verbose = 0) {#
	if (main) {#
		callMat <- matrix(0L, nrow = nrow(df)+1, ncol = nrow(df)+1)#
		dnames <- c(df[,1], "main")#
		dimnames(callMat) <- list(dnames, dnames)#
	}#
#
	if (!main) {#
		callMat <- matrix(0L, nrow = nrow(df), ncol = nrow(df))#
		dnames <- df[,1]#
		dimnames(callMat) <- list(dnames, dnames)#
	}#
	if (Verbose >= 2) message("Searching for function calls")#
	for (i in 1:nrow(df)) {#
		if (df[i,6] == 1) {#
			if (i == nrow(df)) { #
				fileNo <- df[i,3] #
				lineNo <- df[i,4]:df[i,5] #
				callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
					cMat = callMat, exFnNode = exFnNode, addFnCall = addFnCall,#
					exFnCall = exFnCall, Verbose = Verbose)#
				}#
			if (i != nrow(df)) { #
				if (df[i+1,6] == 2) {#
					if (Verbose == 3) message("Looking AHEAD for embedded functions & skipping them")#
					if (df[i+1,3] != df[i,3]) stop("Looking in different files - something is wrong!")#
					fileNo <- df[i,3] #
					keep <- c(NA_integer_) #
					j <- i+1#
					while (j <= nrow(df)) {#
						if (df[j,6] == 2) keep <- c(keep, j)#
						if (df[j,6] != 2) break#
						j <- j + 1#
						}#
					keep <- keep[-1]#
					no <- c(NA_integer_)#
					for (j in 1:length(keep)) {#
						no <- c(no, df[keep[j],4]:df[keep[j],5])#
						}#
					no <- no[-1]#
					yes <- df[i,4]:df[i,5]#
					lineNo <- setdiff(yes, no)#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnNode = exFnNode, addFnCall = addFnCall,#
						exFnCall = exFnCall, Verbose = Verbose)#
					} #
				if (df[i+1,6] == 1) { #
					fileNo <- df[i,3]#
					lineNo <- df[i,4]:df[i,5]#
					callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
						cMat = callMat, exFnNode = exFnNode, addFnCall = addFnCall,#
						exFnCall = exFnCall, Verbose = Verbose)#
					}#
			} #
		} #
		if (df[i,6] == 2) { #
			fileNo <- df[i,3]#
			lineNo <- df[i,4]:df[i,5]#
			callMat <- searchLines(fL = fL, df = df, i = i, fNo = fileNo, lNo = lineNo,#
				cMat = callMat, exFnNode = exFnNode, addFnCall = addFnCall,#
				exFnCall = exFnCall, Verbose = Verbose)#
			}		#
		} #
	return(callMat)#
	} #
dummyFn <- function() {#
	}#
#
dummyFn()#
findFnCallFromMain <- function(fL = NULL, df = NULL, cM = NULL, exFnNode = NULL,#
	addFnCall = NULL, exFnCall = NULL, Verbose = 0) {#
	if (Verbose >= 2) message("Searching for function calls in main")#
	df2 <- subset(df, embedLvl == 1) #
	keep <- unique(df2$fileIdx)	#
	for (i in keep) {		#
		done <- c(NA_integer_)#
		df3 <- subset(df2, fileIdx == i)#
		for (j in 1:nrow(df3)) {#
			done <- c(done, df3[j,4]:df3[j,5])#
			}#
		done  <- done[-1]#
		noLines <- length(fL[[i]])#
		toDo <- setdiff(1:noLines, done)#
		if (length(toDo) == 0) next #
		cM <- searchLines(fL = fL, df = df, i = nrow(cM), fNo = i, lNo = toDo,#
			cMat = cM, exFnNode = exFnNode, addFnCall = addFnCall,#
			exFnCall = exFnCall, Verbose = Verbose)#
		}#
	files <- names(fL)#
	fileNo <- which(!files %in% unique(df[,2]))#
	for (i in fileNo) {#
		cM <- searchLines(fL = fL, df = df, i = nrow(cM), fNo = i, lNo = 1:length(fL[[i]]),#
			cMat = cM, exFnNode = exFnNode, addFnCall = addFnCall,#
			exFnCall = exFnCall, Verbose = Verbose)#
		}#
	return(cM)#
	} #
searchLines <- function(fL = NULL, df = NULL, i = NULL, fNo = NULL,#
	lNo = NULL, cMat = NULL, exFnNode = NULL, addFnCall = NULL,#
	exFnCall = NULL, Verbose = 0) {#
	sp <- paste(df[,1], "\\(", sep = "") #
	spl <- length(sp)#
	if (!is.null(addFnCall)) sp <- c(sp, paste(addFnCall, df[,1], sep = ""))#
	for (k in 1:length(sp)) {#
		if (Verbose >= 2) cat("\tSearching for function: ", sp[k], "\n")#
		for (j in lNo) {#
			if (grepl(sp[k], fL[[fNo]][j])) {#
				if (!is.null(exFnCall)) {#
					for (n in 1:length(exFnCall)) {#
						if ((grepl(sp[k], fL[[fNo]][j])) & (!grepl(exFnCall[n], fL[[fNo]][j]))) {#
							clm <- ifelse((k %% spl) == 0, k, (k %% spl))		#
							cMat[i, clm] <- 1L#
							if (Verbose >= 2) {#
								msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
									"\n\t\t\t\tin file", names(fL)[fNo],#
									"at line", j, "\n", sep = " ")#
								cat(msg)#
								}#
							}#
						if ((grepl(sp[k], fL[[fNo]][j])) & (grepl(exFnCall[n], fL[[fNo]][j]))) {#
							if (Verbose >= 2) {#
								msg <- paste("\t\tSkipping:", exFnCall[n], "\n")#
								cat(msg)#
								}#
							}#
						}#
					}#
				if (is.null(exFnCall)) {#
					clm <- ifelse((k %% spl) == 0, k, (k %% spl))		#
					cMat[i, clm] <- 1L#
					if (Verbose >= 2) {#
						msg <- paste("\t\t", df[k,1], "is called by", df[i,1],#
							"\n\t\t\t\tin file", names(fL)[fNo],#
							"at line", j, "\n", sep = " ")#
						cat(msg)#
						}#
					 }#
				}#
			}#
		}#
	return(cMat)#
	} #
findEmbedFn <- function(df) {#
	fnLevel <- c(1L) #
	currL1 <- 1L #
	for (i in 2:nrow(df)) {#
		chk <- ((df[i,4] < df[currL1,5]) & (df[i,5] < df[currL1,5]))#
		eb <- ifelse(chk, 2, 1)#
		currL1 <- ifelse(chk, currL1, i)#
		fnLevel <- c(fnLevel, eb)#
		}#
	return(fnLevel)#
	}
plotCallGraph <- function(cG, ...) {#
	require("sna")#
	wd <- unlist(strsplit(getwd(), split = "/"))#
	charMax <- 30#
	charCount <- cumsum(rev(nchar(wd)))#
	pick <- which(charCount <= charMax)#
	dString <- paste(wd[(length(wd)-length(pick)):length(wd)], collapse = "/")#
	dString <- paste("...", dString, sep = "/")#
	cString <- cG[[3]]#
	if (length(cString) > 1) cString <- paste(cString, collapse = "")#
	titleText <- paste(cString, "on directory", dString, sep = " ")#
	titleText <- strwrap(titleText)#
	cexM <- ifelse(length(titleText > 3), 0.9, 1.2)#
	title <- paste(titleText, collapse = "\n")#
	vc <- "red"#
	fn <- unlist(dimnames(cG[[1]])[1])#
	if ("main" %in% fn) {#
		vc <- rep("red", length(fn))#
		m <- grep("main", fn)#
		vc[m] <- "blue"#
		}#
	tmp <- gplot(cG[[1]], displaylabels = TRUE, label.cex = 0.6, cex.main = cexM, loop.cex = 2,#
		arrowhead.cex = 0.5, label.pos = 6, diag = TRUE, mode = "circle", main = title,#
		vertex.col = vc, ...)#
	}
callGraph <- function(lang = "d3", ext = NULL,#
	excludeFile = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, #
	exFnNode = NULL, addFnCall = NULL, exFnCall = NULL,#
	main = TRUE, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	theCall <- deparse(sys.call()) #
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\s*\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
#
	if (verbose >= 1) cat("\n")#
   	for (i in 1:length(filesL)) { #
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				if (!is.null(exFnNode)) {#
					for (n in 1:length(exFnNode)) {#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (!grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							fnNames <- c(fnNames, filesL[[i]][j])#
							fnFileNames <- c(fnFileNames, names(filesL)[i])#
							fnFileNo <- c(fnFileNo, i)#
							fnSt <- c(fnSt, j)#
							Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
							end <- findFnDefinition(fL = filesL, i = i, j = j,#
								jmax = length(filesL[[i]]), Verbose = Verbose)#
			 				fnEnd <- c(fnEnd, end)#
							}#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							message("skipping one")#
							}#
						}#
					}#
#
				if (is.null(exFnNode)) {#
					fnNames <- c(fnNames, filesL[[i]][j])#
					fnFileNames <- c(fnFileNames, names(filesL)[i])#
					fnFileNo <- c(fnFileNo, i)#
					fnSt <- c(fnSt, j)#
					Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
					end <- findFnDefinition(fL = filesL, i = i, j = j,#
						jmax = length(filesL[[i]]), Verbose = Verbose)#
	 				fnEnd <- c(fnEnd, end)#
					}#
				}		#
	     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
	fnFileNames <- fnFileNames[-1]#
	fnFileNo <- fnFileNo[-1]#
	fnSt <- fnSt[-1]#
	fnEnd <- fnEnd[-1]#
	if (verbose >= 2) {#
	 	cat("fnNames are:", fnNames, "\n")#
	 	cat("There are", length(fnNames), "functions total\n\n")#
	 	cat("fnFileNames are:", fnFileNames, "\n")#
	 	cat("There are:", length(fnFileNames), "files containing those functions\n\n")#
	 	cat("fileIdx is:", fnFileNo, "\n")#
	 	cat(length(fnFileNo), "files were found\n\n")#
	 	cat("stLine is:", fnSt, "\n")#
	  	cat(length(fnSt), "opening braces were found\n\n")#
		cat("endLine is:", fnEnd, "\n")#
	 	cat(length(fnEnd), "closing braces were found\n\n")#
		}#
    df <- data.frame(fnName = fnNames, file = fnFileNames,#
    		fileIdx = fnFileNo, stLine = fnSt, endLine = fnEnd,#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("\n*** WARNING: duplicate function names were found ***\n")#
    df <- df[!dup,]#
	keep <- unique(df$fileIdx)#
	embedLvl <- c(NA_integer_)#
	if (verbose >= 2) message("Checking embed depth")#
  	for (i in keep) {#
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		embedLvl <- c(embedLvl, tmp)#
		}#
	embedLvl <- embedLvl[-1]#
	df$embedLvl <- embedLvl#
    if (verbose >= 1L) {#
    		message("\nDone processing files, ready to map the function calls")#
    		if (verbose == 1) message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose => 2L, TRUE, FALSE)#
 	cM <- findFnCallInFn(fL = filesL, df = df, exFnNode = exFnNode, addFnCall = addFnCall,#
 		exFnCall = exFnCall, main = main, Verbose = verbose)#
	Verbose <- ifelse(verbose => 2L, TRUE, FALSE)#
	if (main) cM <- findFnCallFromMain(fL = filesL, df = df, cM = cM,#
		exFnNode = exFnNode, addFnCall = addFnCall, exFnCall = exFnCall,#
		Verbose = Verbose)#
#
    if (verbose >= 1L) message("Done mapping the function calls")#
    	retVal <- list(callMatrix = cM, functionDef = df, call = theCall)#
    class(retVal) <- "callGraph"#
    return(retVal)#
	}
callGraph <- function(lang = "d3", ext = NULL,#
	excludeFile = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, #
	exFnNode = NULL, addFnCall = NULL, exFnCall = NULL,#
	main = TRUE, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	theCall <- deparse(sys.call()) #
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\s*\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
#
	if (verbose >= 1) cat("\n")#
   	for (i in 1:length(filesL)) { #
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				if (!is.null(exFnNode)) {#
					for (n in 1:length(exFnNode)) {#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (!grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							fnNames <- c(fnNames, filesL[[i]][j])#
							fnFileNames <- c(fnFileNames, names(filesL)[i])#
							fnFileNo <- c(fnFileNo, i)#
							fnSt <- c(fnSt, j)#
							Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
							end <- findFnDefinition(fL = filesL, i = i, j = j,#
								jmax = length(filesL[[i]]), Verbose = Verbose)#
			 				fnEnd <- c(fnEnd, end)#
							}#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							message("skipping one")#
							}#
						}#
					}#
#
				if (is.null(exFnNode)) {#
					fnNames <- c(fnNames, filesL[[i]][j])#
					fnFileNames <- c(fnFileNames, names(filesL)[i])#
					fnFileNo <- c(fnFileNo, i)#
					fnSt <- c(fnSt, j)#
					Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
					end <- findFnDefinition(fL = filesL, i = i, j = j,#
						jmax = length(filesL[[i]]), Verbose = Verbose)#
	 				fnEnd <- c(fnEnd, end)#
					}#
				}		#
	     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
	fnFileNames <- fnFileNames[-1]#
	fnFileNo <- fnFileNo[-1]#
	fnSt <- fnSt[-1]#
	fnEnd <- fnEnd[-1]#
	if (verbose >= 2) {#
	 	cat("fnNames are:", fnNames, "\n")#
	 	cat("There are", length(fnNames), "functions total\n\n")#
	 	cat("fnFileNames are:", fnFileNames, "\n")#
	 	cat("There are:", length(fnFileNames), "files containing those functions\n\n")#
	 	cat("fileIdx is:", fnFileNo, "\n")#
	 	cat(length(fnFileNo), "files were found\n\n")#
	 	cat("stLine is:", fnSt, "\n")#
	  	cat(length(fnSt), "opening braces were found\n\n")#
		cat("endLine is:", fnEnd, "\n")#
	 	cat(length(fnEnd), "closing braces were found\n\n")#
		}#
    df <- data.frame(fnName = fnNames, file = fnFileNames,#
    		fileIdx = fnFileNo, stLine = fnSt, endLine = fnEnd,#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("\n*** WARNING: duplicate function names were found ***\n")#
    df <- df[!dup,]#
	keep <- unique(df$fileIdx)#
	embedLvl <- c(NA_integer_)#
	if (verbose >= 2) message("Checking embed depth")#
  	for (i in keep) {#
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		embedLvl <- c(embedLvl, tmp)#
		}#
	embedLvl <- embedLvl[-1]#
	df$embedLvl <- embedLvl#
    if (verbose >= 1L) {#
    		message("\nDone processing files, ready to map the function calls")#
    		if (verbose == 1) message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
 	cM <- findFnCallInFn(fL = filesL, df = df, exFnNode = exFnNode, addFnCall = addFnCall,#
 		exFnCall = exFnCall, main = main, Verbose = verbose)#
	Verbose <- ifelse(verbose => 2L, TRUE, FALSE)#
	if (main) cM <- findFnCallFromMain(fL = filesL, df = df, cM = cM,#
		exFnNode = exFnNode, addFnCall = addFnCall, exFnCall = exFnCall,#
		Verbose = Verbose)#
#
    if (verbose >= 1L) message("Done mapping the function calls")#
    	retVal <- list(callMatrix = cM, functionDef = df, call = theCall)#
    class(retVal) <- "callGraph"#
    return(retVal)#
	}
callGraph <- function(lang = "d3", ext = NULL,#
	excludeFile = NULL,#
	fnPat = NULL, cPat = NULL, comPat = NULL, #
	exFnNode = NULL, addFnCall = NULL, exFnCall = NULL,#
	main = TRUE, verbose = 1L) {#
	require(gsubfn)#
	require(stringr)#
	theCall <- deparse(sys.call()) #
	if (!is.null(lang)) {	#
		langs <- c("d3", "R")#
		if (!lang %in% langs) stop("Can't handle the language you requested")#
		if (lang == "d3") {#
			ext <- "js|JS" #
			fnPat <- "function\\({1}[^d|i]" #
			cPat <- "\\s*var\\s*([[:alnum:]]+)\\s*=" #
			comPat <- "^[[:blank:]]*//" #
			}#
#
		if (lang == "R") {#
			ext <- "r|R" #
			fnPat <- "function\\s*\\(" #
			cPat <- "\\s*([[:alnum:]]+)\\s*\\<-\\s*function" #
			comPat <- "^[[:blank:]]*#"#
			}#
		}#
	if (is.null(fnPat)) stop("No language given, so fnPat must be provided")#
	if (is.null(cPat)) stop("No language given, so cPat must be provided")#
	if (is.null(comPat)) stop("No language given, so comPat must be provided")#
	pat <- paste("\\.(", ext, ")$", sep = "")#
	files <- list.files(pattern = pat)#
    if (!is.null(excludeFile)) {#
    	   		if (verbose >= 1L) {#
     			msg <- paste("Excluding:", excludeFile, "from the analysis", sep = " ")#
 				message(msg)#
				}#
	    	for (i in seq_along(excludeFile)) files <- files[!grepl(excludeFile[i], files)]#
		}#
	nfiles <- length(files)#
	filesL <- vector("list", nfiles) #
	fnNames <- c(NA_character_) #
	fnFileNames <- c(NA_character_) #
	fnFileNo <- c(NA_integer_) #
	fnSt <- c(NA_integer_) #
	fnEnd <- c(NA_integer_) #
    for (i in seq_along(files)) filesL[[i]] <- readLines(files[i])#
	names(filesL) <- files#
   	for (i in 1:length(filesL)) {#
   		if (verbose >= 1L) {#
     		msg <- paste("Removing commented & blank lines in:", names(filesL)[i], sep = " ")#
 			message(msg)#
			}#
		comL <- c(NA_integer_) #
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = comPat, x = filesL[[i]][j])) {#
				comL <- c(comL, j)#
				}#
			if (filesL[[i]][j] == "") {#
				comL <- c(comL, j)#
				}#
     		}#
     	comL <- comL[-1] #
     	if (length(comL) == 0) next #
     	filesL[[i]] <- filesL[[i]][-comL]#
	} #
#
	if (verbose >= 1) cat("\n")#
   	for (i in 1:length(filesL)) { #
   		if (verbose >= 1L) {#
	     	msg <- paste("Looking for function definitions in:", names(filesL)[i], sep = " ")#
	 		message(msg)#
			}#
		for (j in 1:length(filesL[[i]])) {#
			if (grepl(pattern = fnPat, x = filesL[[i]][j])) {#
				if (!is.null(exFnNode)) {#
					for (n in 1:length(exFnNode)) {#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (!grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							fnNames <- c(fnNames, filesL[[i]][j])#
							fnFileNames <- c(fnFileNames, names(filesL)[i])#
							fnFileNo <- c(fnFileNo, i)#
							fnSt <- c(fnSt, j)#
							Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
							end <- findFnDefinition(fL = filesL, i = i, j = j,#
								jmax = length(filesL[[i]]), Verbose = Verbose)#
			 				fnEnd <- c(fnEnd, end)#
							}#
						if ((grepl(pattern = fnPat, x = filesL[[i]][j])) & (grepl(pattern = exFnNode[n], x = filesL[[i]][j]))) {#
							message("skipping one")#
							}#
						}#
					}#
#
				if (is.null(exFnNode)) {#
					fnNames <- c(fnNames, filesL[[i]][j])#
					fnFileNames <- c(fnFileNames, names(filesL)[i])#
					fnFileNo <- c(fnFileNo, i)#
					fnSt <- c(fnSt, j)#
					Verbose <- ifelse(verbose == 3L, TRUE, FALSE)#
					end <- findFnDefinition(fL = filesL, i = i, j = j,#
						jmax = length(filesL[[i]]), Verbose = Verbose)#
	 				fnEnd <- c(fnEnd, end)#
					}#
				}		#
	     	}     #
	} #
 	fnNames <- unlist(strapply(pattern = cPat, replacement = paste0, X = fnNames))#
	fnFileNames <- fnFileNames[-1]#
	fnFileNo <- fnFileNo[-1]#
	fnSt <- fnSt[-1]#
	fnEnd <- fnEnd[-1]#
	if (verbose >= 2) {#
	 	cat("fnNames are:", fnNames, "\n")#
	 	cat("There are", length(fnNames), "functions total\n\n")#
	 	cat("fnFileNames are:", fnFileNames, "\n")#
	 	cat("There are:", length(fnFileNames), "files containing those functions\n\n")#
	 	cat("fileIdx is:", fnFileNo, "\n")#
	 	cat(length(fnFileNo), "files were found\n\n")#
	 	cat("stLine is:", fnSt, "\n")#
	  	cat(length(fnSt), "opening braces were found\n\n")#
		cat("endLine is:", fnEnd, "\n")#
	 	cat(length(fnEnd), "closing braces were found\n\n")#
		}#
    df <- data.frame(fnName = fnNames, file = fnFileNames,#
    		fileIdx = fnFileNo, stLine = fnSt, endLine = fnEnd,#
    		stringsAsFactors = FALSE)#
    dup <- duplicated(df[,1])#
    if (any(dup)) message("\n*** WARNING: duplicate function names were found ***\n")#
    df <- df[!dup,]#
	keep <- unique(df$fileIdx)#
	embedLvl <- c(NA_integer_)#
	if (verbose >= 2) message("Checking embed depth")#
  	for (i in keep) {#
		df2 <- subset(df, fileIdx == i)#
		if (nrow(df2) == 1) tmp <- 1#
		if (nrow(df2) != 1) tmp <- findEmbedFn(df2)#
		embedLvl <- c(embedLvl, tmp)#
		}#
	embedLvl <- embedLvl[-1]#
	df$embedLvl <- embedLvl#
    if (verbose >= 1L) {#
    		message("\nDone processing files, ready to map the function calls")#
    		if (verbose == 1) message("Set verbose = 2 or 3 to see details of the mapping process")#
    		}#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
 	cM <- findFnCallInFn(fL = filesL, df = df, exFnNode = exFnNode, addFnCall = addFnCall,#
 		exFnCall = exFnCall, main = main, Verbose = verbose)#
	Verbose <- ifelse(verbose >= 2L, TRUE, FALSE)#
	if (main) cM <- findFnCallFromMain(fL = filesL, df = df, cM = cM,#
		exFnNode = exFnNode, addFnCall = addFnCall, exFnCall = exFnCall,#
		Verbose = Verbose)#
#
    if (verbose >= 1L) message("Done mapping the function calls")#
    	retVal <- list(callMatrix = cM, functionDef = df, call = theCall)#
    class(retVal) <- "callGraph"#
    return(retVal)#
	}
tst <- callGraph(lang = "R")
tmp <- plotCallGraph(tst)
exCon(M = volcano)
library(devtools)
document()
findFn("find non-ascii")
getwd()
list.files9
list.files()
tmp <- readLines(exCon.R)
?grep
grep("I_WAS_NOT_ASCII", iconv(tmp, "latin1", "ASCII", sub="I_WAS_NOT_ASCII"))
tmp <- readLines("exCon.R")
tmp[87:89]
library("exCon")
?exCon
exCon(M = volcano, browser = "/usr/bin/open -a 'Firefox'")
exCon(M = volcano, browser = "/usr/bin/open -a 'Chrome'")
exCon(M = volcano, browser = "/usr/bin/open -a 'Safari'")
library("R.utils")
den <- loadObject('~/Documents/Research/MetabolomicsProjects/ChemometricsStuff/BAHpackages/exCon Support/n40w106NE.Rdata')
str(den)
exCon(M = den)
exCon(M = den[1:4000,1:4000])
